#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Created on Sun May 22 14:37:37 2016

@author: wxt

"""
import argparse, sys, os, logging, logging.handlers, traceback, domaincaller

currentVersion = domaincaller.__version__

def getargs():
    ## Construct an ArgumentParser object for command-line arguments
    parser = argparse.ArgumentParser(usage = '%(prog)s <--uri cool -O output> [options]',
                                     description = '''A python implementation of original DI-based
                                     domain caller proposed by Dixon et al. (2012)''',
                                     formatter_class = argparse.ArgumentDefaultsHelpFormatter)
    
    parser.add_argument('-v', '--version', action = 'version',
                        version = ' '.join(['%(prog)s', currentVersion]),
                        help = 'Print version number and exit')

    # Output
    parser.add_argument('--uri',
                        help = 'Cool URI.')
    parser.add_argument('-O', '--output')
    parser.add_argument('-D', '--DI-output')
    parser.add_argument('--window-size', default=2000000, type=int,
                        help='''Window size used for directionality index (DI) calculation.''')
    parser.add_argument('-W', '--weight-col', default='weight',
                        help = '''Name of the column in .cool to be used to construct the
                        normalized matrix. Specify "-W RAW" if you want to run with the raw matrix.''')
    parser.add_argument('--exclude', nargs = '*', default = ['chrY','chrM'],
                        help = '''List of chromosomes to exclude.''')
    parser.add_argument('-p', '--cpu-core', type = int, default = 1,
                        help = 'Number of processes to launch.')
    
    parser.add_argument('--logFile', default = 'domaincaller.log', help = '''Logging file name.''')
    
    ## Parse the command-line arguments
    commands = sys.argv[1:]
    if not commands:
        commands.append('-h')
    args = parser.parse_args(commands)
    
    return args, commands

def run():
    # Parse Arguments
    args, commands = getargs()
    # Improve the performance if you don't want to run it
    if commands[0] not in ['-h', '-v', '--help', '--version']:
        ## Root Logger Configuration
        logger = logging.getLogger()
        logger.setLevel(10)
        console = logging.StreamHandler()
        filehandler = logging.handlers.RotatingFileHandler(args.logFile,
                                                           maxBytes = 200000,
                                                           backupCount = 5)
        # Set level for Handlers
        console.setLevel('INFO')
        filehandler.setLevel('DEBUG')
        # Customizing Formatter
        formatter = logging.Formatter(fmt = '%(name)-25s %(levelname)-7s @ %(asctime)s: %(message)s',
                                      datefmt = '%m/%d/%y %H:%M:%S')
        ## Unified Formatter
        console.setFormatter(formatter)
        filehandler.setFormatter(formatter)
        # Add Handlers
        logger.addHandler(console)
        logger.addHandler(filehandler)
        
        ## Logging for argument setting
        arglist = ['# ARGUMENT LIST:',
                   '# Output TAD file = {0}'.format(args.output),
                   '# Output DI file = {0}'.format(args.DI_output),
                   '# Cool URI = {0}'.format(args.uri),
                   '# Window Size = {0}'.format(args.window_size),
                   '# Column for matrix balancing = {0}'.format(args.weight_col),
                   '# Excluded Chromosomes = {0}'.format(args.exclude),
                   '# Number of processes used = {0}'.format(args.cpu_core),
                   '# Log file name = {0}'.format(args.logFile)
                   ]
        
        argtxt = '\n'.join(arglist)
        logger.info('\n' + argtxt)
        
        from domaincaller.genomeLev import Genome
        from domaincaller.chromLev import Chrom, extract_matrix
        import numpy as np
        
        try:
            if not args.weight_col in ['weight']:
                correct = False
            else:
                correct = args.weight_col

            G = Genome(args.uri, balance_type=correct, window=args.window_size, exclude=args.exclude)
            logger.info('Fit Hidden Markov Models with up to 20 mixtures ...')
            #maxM = 3
            maxM = 20
            aic = np.ones(maxM) * 10000000
            Ks = np.zeros(maxM, dtype=int)
            candidates = []
            for i in range(1, maxM+1):
                logger.info('Mixture Number: {0}'.format(i))

                K = 0 # Number of Parameters for AIC Calculation
                # Gaussian Mixture Model Parameters
                K += (3 * (3 * i))
                # HMM parameters
                K += 9 # transition matrix
                #K += 3 # start probabilities

                model = G.oriHMMParams(numdists=i)
                model.fit(G.training_data, algorithm='baum-welch', max_iterations=10000,
                          stop_threshold=1e-5, n_jobs=args.cpu_core, verbose=False)
                candidates.append(model)
                #print("Edges: {0}".format(model.get_params()['edges']))
                
                logL = sum(model.log_probability(seq) for seq in G.training_data)
                aic[i-1] = -2 * logL + 2 * K
                Ks[i-1] = K

                logger.info('Log likelihood: {0}, AIC value: {1}, Parameter Number: {2}'.format(logL, aic[i-1], K))
            
            # Apply AIC
            order = np.int(np.floor(np.log10(abs(aic.min())))) - 1
            div = np.power(10, order)
            
            # Relative probability
            for i in range(maxM):
                p_aic = np.exp((aic.min() - aic[i]) / (div * 2))
                if p_aic >= 0.9:
                    idx = i
                    break
            model = candidates[idx]
            logger.info('HMM with {0} mixtures achieved the best performance'.format(idx+1))

            logger.info('Inferring TADs ...')
            DIout = open(args.DI_output, 'w')
            out = open(args.output, 'w')
            for c in G.chroms:
                logger.info('{0} ...'.format(c))
                tdata = extract_matrix(G.hic, c, correct)
                work = Chrom(c, G.hic.binsize, tdata)
                work.callDomains(model, window=args.window_size)
                for d in work.domains:
                    out.write('{0}\t{1}\t{2}\n'.format(c, d[0], d[1]))
                for i, v in enumerate(work.DIs):
                    start = i * G.hic.binsize
                    end = min(start + G.hic.binsize, G.hic.chromsizes[c])
                    DIout.write('{0}\t{1}\t{2}\t{3:.4g}\n'.format(c, start, end, v))

            DIout.close()
            out.close()
            logger.info('Done!')
        except:
            traceback.print_exc(file = open(args.logFile, 'a'))
            sys.exit(1)

if __name__ == '__main__':
    run()